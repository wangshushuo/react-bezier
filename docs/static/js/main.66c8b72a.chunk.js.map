{"version":3,"sources":["App.tsx","serviceWorker.ts","index.tsx"],"names":["key","P","x","y","scale","this","prototype","winWidth","window","innerWidth","size","p","阶乘","n","组合","i","cubic_bezier","t","sum","Math","pow","cb_y","T","length","App","ref","useRef","useLayoutEffect","current","ctx","getContext","margin","base_x","base_y","beginPath","moveTo","lineTo","strokeStyle","stroke","closePath","fontWidth","font","fillText","fillStyle","index","point","element","arc","PI","fill","lineWidth","y0","x1","y1","className","width","height","style","border","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.66c8b72a.chunk.js","sourcesContent":["import React, { useRef, useLayoutEffect } from 'react';\nimport './App.css';\n\n\n/**\n * 相对于坐标系而不是canvase的坐标。\n */\nclass P {\n  x: number;\n  y: number;\n  scale: number = 1;\n  constructor(x: number, y: number) {\n    this.x = x * P.prototype.scale;\n    this.y = y * P.prototype.scale;\n  }\n}\nenum key {\n  x = \"x\",\n  y = \"y\",\n}\n\n\nconst winWidth = window.innerWidth;\nconst maxWidth = 720;\nconst scale = winWidth >= maxWidth ? 1 : winWidth / maxWidth;\n\nP.prototype.scale = scale;\nconst size = 500 * scale;\n\nconst p0 = new P(10, 10);\nconst p1 = new P(100, 300);\nconst p2 = new P(200, 20);\nconst p3 = new P(250, 400)\nconst p4 = new P(500, 20);\n\nconst p = [p0, p1, p2, p3, p4]\n\nfunction 阶乘(n: number): number {\n  if (n === 0) return 1;\n  return n * 阶乘(n - 1)\n}\nfunction 组合(n: number, i: number): number {\n  return 阶乘(n) / (阶乘(i) * 阶乘(n - i))\n}\n/**\n * 计算白塞尔曲线\n * @param t [0,1] 0-1之间的小数\n * @param n 几项白塞尔曲线，默认3项\n * @param key 控制点对象P的key，也就是x或y字符串\n */\nfunction cubic_bezier(t: number, n: number, key: key): number {\n  let sum = 0;\n  for (let i = 0; i <= n; i++) {\n    const tn = 组合(n, i) * p[i][key] * Math.pow(1 - t, n - i) * Math.pow(t, i);\n    sum += tn;\n  }\n  return sum\n}\nfunction cb_x(T: number) {\n  return cubic_bezier(T, p.length - 1, key.x);\n}\nfunction cb_y(T: number) {\n  return cubic_bezier(T, p.length - 1, key.y);\n}\n\nfunction App() {\n  const ref = useRef<HTMLCanvasElement>(null);\n\n  useLayoutEffect(() => {\n    if (ref.current) {\n      const ctx = ref.current.getContext('2d');\n      if (!ctx) return;\n      const margin = size * 0.05;\n      const base_x = margin;\n      const base_y = size * 1.1 - margin;\n\n      // 画标尺\n      ctx.beginPath();\n      ctx.moveTo(base_x, base_x);\n      ctx.lineTo(base_x, base_y);\n      ctx.lineTo(base_y, base_y);\n      ctx.strokeStyle = 'darkred';\n      ctx.stroke();\n      ctx.closePath();\n\n      // 画刻度\n      const fontWidth = size / 100;\n      ctx.font = `${20 * scale}px serif`;\n      ctx.fillText(\"0\", base_x - 2 * fontWidth, base_y + 2 * fontWidth);\n      ctx.fillStyle = 'darkred';\n      for (let index = 1; index <= 10; index++) {\n        ctx.fillText(index + \"\", base_x + index * size / 10, base_y + 2 * fontWidth);\n      }\n      for (let index = 1; index <= 10; index++) {\n        ctx.fillText(index + \"\", base_x - 2 * fontWidth, base_y - index * size / 10);\n      }\n\n      // 画参考线\n      ctx.beginPath();\n      for (let i = 0; i < p.length; i++) {\n        const point = p[i];\n        if (i === 0) ctx.moveTo(base_x + point.x, base_y - point.y);\n        ctx.lineTo(base_x + point.x, base_y - point.y);\n      }\n      ctx.strokeStyle = 'darkgreen';\n      ctx.stroke();\n      ctx.closePath();\n\n      // 画控制点\n      for (let i = 0; i < p.length; i++) {\n        const element = p[i];\n        const x = base_x + element.x;\n        const y = base_y - element.y;\n        ctx.moveTo(x, y);\n        ctx.beginPath();\n        ctx.arc(x, y, fontWidth, 0, Math.PI * 2, true);\n        ctx.closePath();\n        ctx.fillStyle=\"darkgreen\"\n        ctx.fill()\n        ctx.fillText(i + \"\", x + 5, y + 2);\n      }\n      ctx.strokeStyle = 'darkgreen'\n      ctx.stroke();\n\n      // 画曲线\n      ctx.beginPath();\n      ctx.moveTo(base_x + p[0].x, base_y - p[0].y);\n      ctx.lineWidth = 2;\n      for (let index = 1; index < size; index++) {\n        const x0 = base_x;\n        const y0 = base_y;\n\n        const t = index / size;\n\n        // 画贝塞尔曲线\n        const x1 = x0 + cb_x(t);\n        const y1 = y0 - cb_y(t);\n\n        ctx.lineTo(x1, y1);\n      }\n      ctx.strokeStyle = 'blue';\n      ctx.stroke();\n      ctx.closePath();\n    }\n  })\n  return (\n    <div className=\"App\">\n      <h1>贝塞尔曲线</h1>\n      <canvas ref={ref} width={size * 1.1} height={size * 1.1} style={{ margin: 0, border: '1px solid #000' }}></canvas>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}